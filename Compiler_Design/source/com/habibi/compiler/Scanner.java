/* The following code was generated by JFlex 1.3.5 on 11/29/04 10:01 PM */

/* From "Simlpe lang" lexer specification */

/* Note that this lexer specification is not tuned for speed.
   It is in fact quite slow on integer and floating point literals, 
   because the input is read twice and the methods used to parse
   the numbers are not very fast. 
   For a production quality application ,this could be optimized */

package com.habibi.compiler;

import java_cup.runtime.*;


/**
 * This class is a scanner generated by 
 * <a href="http://www.jflex.de/">JFlex</a> 1.3.5
 * on 11/29/04 10:01 PM from the specification file
 * <tt>file:/F:/Documents and Settings/narges/My Documents/narges/new/javacc/myclasses/simple_lang.jflex</tt>
 * this analyse input and according to lexical rules exract tokens and return them to Parser. 
 */
public class Scanner extends sym implements java_cup.runtime.Scanner {

  /** This character denotes the end of file */
  final public static int YYEOF = -1;

  /** initial size of the lookahead buffer */
  final private static int YY_BUFFERSIZE = 16384;

  /** lexical states */
  final public static int STRING = 1;
  final public static int YYINITIAL = 0;
  final public static int CHARLITERAL = 2;

  /** 
   * Translates characters to character classes
   */
  final private static char [] yycmap = {
     7,  7,  7,  7,  7,  7,  7,  7,  7,  3,  2,  0,  3,  1,  7,  7, 
     7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  0,  0,  0,  0, 
     3, 39, 11,  0,  6, 45, 41, 12, 30, 31,  5, 43, 35, 44, 10,  4, 
     8,  9,  9,  9,  9,  9,  9,  9,  9,  9, 40, 34, 38, 36, 37,  0, 
     0,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6, 
     6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  0, 13,  0,  0,  6, 
     0, 15, 46, 23,  6, 25, 21, 28, 24, 16,  6,  6, 26, 14, 17, 27, 
    18,  6, 19, 22, 20,  6,  6, 29,  6,  6,  6, 32, 42, 33,  0,  7
  };

  /** 
   * Translates a state to a row index in the transition table
   */
  final private static int yy_rowMap [] = { 
        0,    47,    94,   141,   188,   141,   235,   282,   329,   376, 
      423,   470,   141,   141,   517,   564,   611,   658,   705,   752, 
      799,   846,   893,   141,   141,   141,   141,   141,   141,   940, 
      987,  1034,  1081,   141,  1128,  1175,  1222,  1269,  1316,  1363, 
     1410,   141,   141,  1457,  1504,  1551,   141,  1598,  1645,   141, 
      141,   376,   470,  1692,  1739,   329,  1786,  1833,  1880,  1927, 
     1974,  2021,  2068,  2115,   141,   141,   141,   141,   141,   141, 
      141,   141,   141,   141,   141,   141,   141,   141,   141,   141, 
      141,   141,   141,   141,   141,  2162,  2209,  2256,  2303,  2350, 
     2397,  2444,  2491,  2538,  2585,   329,  2632,  2679,   329,  2726, 
     2773,  2820,  2867,  2914,   141,   141,   141,   141,   141,   141, 
      141,   141,  2961,   329,  3008,  3055,  3102,   329,   329,   329, 
     3149,  3196,   329,   329,   329,   329
  };

  /** 
   * The packed transition table of the DFA (part 0)
   */
  final private static String yy_packed0 = 
    "\1\4\1\5\2\6\1\7\1\10\1\11\1\4\1\12"+
    "\1\13\1\14\1\15\1\16\1\4\1\17\1\11\1\20"+
    "\1\11\1\21\2\11\1\22\1\23\1\24\1\11\1\25"+
    "\2\11\1\26\1\27\1\30\1\31\1\32\1\33\1\34"+
    "\1\35\1\36\1\37\1\40\1\41\1\42\1\43\1\44"+
    "\1\45\1\46\1\47\1\11\1\50\1\51\1\52\10\50"+
    "\1\53\1\50\1\54\41\50\1\55\1\56\1\57\11\55"+
    "\1\4\1\60\41\55\61\0\1\6\61\0\1\61\36\0"+
    "\1\62\56\0\1\63\20\0\4\11\4\0\20\11\20\0"+
    "\1\11\10\0\2\64\1\65\54\0\2\13\1\65\54\0"+
    "\2\65\53\0\4\11\4\0\1\11\1\66\16\11\20\0"+
    "\1\11\6\0\4\11\4\0\3\11\1\67\3\11\1\70"+
    "\10\11\20\0\1\11\6\0\4\11\4\0\5\11\1\71"+
    "\12\11\20\0\1\11\6\0\4\11\4\0\14\11\1\72"+
    "\1\73\2\11\20\0\1\11\6\0\4\11\4\0\11\11"+
    "\1\74\6\11\20\0\1\11\6\0\4\11\4\0\12\11"+
    "\1\75\5\11\20\0\1\11\6\0\4\11\4\0\14\11"+
    "\1\76\3\11\20\0\1\11\6\0\4\11\4\0\15\11"+
    "\1\77\2\11\20\0\1\11\6\0\4\11\4\0\12\11"+
    "\1\100\5\11\20\0\1\11\44\0\1\101\56\0\1\102"+
    "\56\0\1\103\56\0\1\104\63\0\1\105\57\0\1\106"+
    "\50\0\1\107\6\0\1\110\47\0\1\111\7\0\1\112"+
    "\46\0\1\113\12\0\1\50\2\0\10\50\1\0\1\50"+
    "\1\0\41\50\2\0\1\52\54\0\2\114\1\0\10\114"+
    "\1\115\1\116\1\117\3\114\1\120\1\114\1\121\1\122"+
    "\1\123\30\114\1\124\14\0\1\125\44\0\1\57\54\0"+
    "\2\114\1\0\10\114\1\126\1\127\1\130\3\114\1\131"+
    "\1\114\1\132\1\133\1\134\30\114\1\135\5\136\1\0"+
    "\51\136\6\0\4\11\4\0\2\11\1\137\15\11\20\0"+
    "\1\11\6\0\4\11\4\0\6\11\1\140\11\11\20\0"+
    "\1\11\6\0\4\11\4\0\2\11\1\141\15\11\20\0"+
    "\1\11\6\0\4\11\4\0\15\11\1\142\2\11\20\0"+
    "\1\11\6\0\4\11\4\0\5\11\1\143\12\11\20\0"+
    "\1\11\6\0\4\11\4\0\1\11\1\144\16\11\20\0"+
    "\1\11\6\0\4\11\4\0\1\11\1\145\16\11\20\0"+
    "\1\11\6\0\4\11\4\0\10\11\1\146\7\11\20\0"+
    "\1\11\6\0\4\11\4\0\6\11\1\147\11\11\20\0"+
    "\1\11\6\0\4\11\4\0\2\11\1\150\15\11\20\0"+
    "\1\11\14\0\1\151\56\0\1\152\56\0\1\153\56\0"+
    "\1\154\56\0\1\155\56\0\1\156\56\0\1\157\56\0"+
    "\1\160\42\0\5\136\1\161\51\136\6\0\4\11\4\0"+
    "\3\11\1\162\14\11\20\0\1\11\6\0\4\11\4\0"+
    "\3\11\1\163\14\11\20\0\1\11\6\0\4\11\4\0"+
    "\1\11\1\164\16\11\20\0\1\11\6\0\4\11\4\0"+
    "\3\11\1\165\14\11\20\0\1\11\6\0\4\11\4\0"+
    "\5\11\1\166\12\11\20\0\1\11\6\0\4\11\4\0"+
    "\13\11\1\167\4\11\20\0\1\11\6\0\4\11\4\0"+
    "\15\11\1\170\2\11\20\0\1\11\6\0\4\11\4\0"+
    "\14\11\1\171\3\11\20\0\1\11\4\136\1\6\1\161"+
    "\51\136\6\0\4\11\4\0\6\11\1\172\11\11\20\0"+
    "\1\11\6\0\4\11\4\0\6\11\1\173\11\11\20\0"+
    "\1\11\6\0\4\11\4\0\7\11\1\174\10\11\20\0"+
    "\1\11\6\0\4\11\4\0\13\11\1\175\4\11\20\0"+
    "\1\11\6\0\4\11\4\0\7\11\1\176\10\11\20\0"+
    "\1\11";

  /** 
   * The transition table of the DFA
   */
  final private static int yytrans [] = yy_unpack();


  /* error codes */
  final private static int YY_UNKNOWN_ERROR = 0;
  final private static int YY_ILLEGAL_STATE = 1;
  final private static int YY_NO_MATCH = 2;
  final private static int YY_PUSHBACK_2BIG = 3;

  /* error messages for the codes above */
  final private static String YY_ERROR_MSG[] = {
    "Unkown internal scanner error",
    "Internal error: unknown state",
    "Error: could not match input",
    "Error: pushback value was too large"
  };

  /**
   * YY_ATTRIBUTE[aState] contains the attributes of state <code>aState</code>
   */
  private final static byte YY_ATTRIBUTE[] = {
     0,  0,  0,  9,  1,  9,  1,  1,  1,  1,  1,  1,  9,  9,  1,  1, 
     1,  1,  1,  1,  1,  1,  1,  9,  9,  9,  9,  9,  9,  1,  1,  1, 
     1,  9,  1,  1,  1,  1,  1,  1,  1,  9,  9,  1,  1,  1,  9,  1, 
     0,  9,  9,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1, 
     9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9, 
     9,  9,  9,  9,  9,  1,  1,  1,  1,  1,  1,  1,  1,  0,  1,  1, 
     1,  1,  1,  1,  1,  1,  1,  1,  9,  9,  9,  9,  9,  9,  9,  9, 
     0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1
  };

  /** the input device */
  private java.io.Reader yy_reader;

  /** the current state of the DFA */
  private int yy_state;

  /** the current lexical state */
  private int yy_lexical_state = YYINITIAL;

  /** this buffer contains the current text to be matched and is
      the source of the yytext() string */
  private char yy_buffer[] = new char[YY_BUFFERSIZE];

  /** the textposition at the last accepting state */
  private int yy_markedPos;

  /** the textposition at the last state to be included in yytext */
  private int yy_pushbackPos;

  /** the current text position in the buffer */
  private int yy_currentPos;

  /** startRead marks the beginning of the yytext() string in the buffer */
  private int yy_startRead;

  /** endRead marks the last character in the buffer, that has been read
      from input */
  private int yy_endRead;

  /** number of newlines encountered up to the start of the matched text */
  private int yyline;

  /** the number of characters up to the start of the matched text */
  private int yychar;

  /**
   * the number of characters from the last newline up to the start of the 
   * matched text
   */
  private int yycolumn; 

  /** 
   * yy_atBOL == true <=> the scanner is currently at the beginning of a line
   */
  private boolean yy_atBOL = true;

  /** yy_atEOF == true <=> the scanner is at the EOF */
  private boolean yy_atEOF;

  /** denotes if the user-EOF-code has already been executed */
  private boolean yy_eof_done;

  /* user code: */
  StringBuffer string = new StringBuffer();
  
  private Symbol symbol(int type) {
    return new Symbol(type, yyline+1, yycolumn+1);
  }

  private Symbol symbol(int type, Object value) {
    return new Symbol(type, yyline+1, yycolumn+1, value);
  }

  /* assumes correct representation of a long value for 
     specified radix in String s */
  private long parseLong(String s, int radix) {
    int  max = s.length();
    long result = 0;
    long digit;

    for (int i = 0; i < max; i++) {
      digit  = Character.digit(yy_buffer[i],radix);
      result*= radix;
      result+= digit;
    }

    return result;
  }


  /**
   * Creates a new scanner
   * There is also a java.io.InputStream version of this constructor.
   *
   * @param   in  the java.io.Reader to read input from.
   */
  public Scanner(java.io.Reader in) {
    this.yy_reader = in;
  }

  /**
   * Creates a new scanner.
   * There is also java.io.Reader version of this constructor.
   *
   * @param   in  the java.io.Inputstream to read input from.
   */
  public Scanner(java.io.InputStream in) {
    this(new java.io.InputStreamReader(in));
  }

  /** 
   * Unpacks the split, compressed DFA transition table.
   *
   * @return the unpacked transition table
   */
  private static int [] yy_unpack() {
    int [] trans = new int[3243];
    int offset = 0;
    offset = yy_unpack(yy_packed0, offset, trans);
    return trans;
  }

  /** 
   * Unpacks the compressed DFA transition table.
   *
   * @param packed   the packed transition table
   * @return         the index of the last entry
   */
  private static int yy_unpack(String packed, int offset, int [] trans) {
    int i = 0;       /* index in packed string  */
    int j = offset;  /* index in unpacked array */
    int l = packed.length();
    while (i < l) {
      int count = packed.charAt(i++);
      int value = packed.charAt(i++);
      value--;
      do trans[j++] = value; while (--count > 0);
    }
    return j;
  }


  /**
   * Refills the input buffer.
   *
   * @return      <code>false</code>, iff there was new input.
   * 
   * @exception   IOException  if any I/O-Error occurs
   */
  private boolean yy_refill() throws java.io.IOException {

    /* first: make room (if you can) */
    if (yy_startRead > 0) {
      System.arraycopy(yy_buffer, yy_startRead, 
                       yy_buffer, 0, 
                       yy_endRead-yy_startRead);

      /* translate stored positions */
      yy_endRead-= yy_startRead;
      yy_currentPos-= yy_startRead;
      yy_markedPos-= yy_startRead;
      yy_pushbackPos-= yy_startRead;
      yy_startRead = 0;
    }

    /* is the buffer big enough? */
    if (yy_currentPos >= yy_buffer.length) {
      /* if not: blow it up */
      char newBuffer[] = new char[yy_currentPos*2];
      System.arraycopy(yy_buffer, 0, newBuffer, 0, yy_buffer.length);
      yy_buffer = newBuffer;
    }

    /* finally: fill the buffer with new input */
    int numRead = yy_reader.read(yy_buffer, yy_endRead, 
                                            yy_buffer.length-yy_endRead);

    if (numRead < 0) {
      return true;
    }
    else {
      yy_endRead+= numRead;  
      return false;
    }
  }


  /**
   * Closes the input stream.
   */
  final public void yyclose() throws java.io.IOException {
    yy_atEOF = true;            /* indicate end of file */
    yy_endRead = yy_startRead;  /* invalidate buffer    */

    if (yy_reader != null)
      yy_reader.close();
  }


  /**
   * Closes the current stream, and resets the
   * scanner to read from a new input stream.
   *
   * All internal variables are reset, the old input stream 
   * <b>cannot</b> be reused (internal buffer is discarded and lost).
   * Lexical state is set to <tt>YY_INITIAL</tt>.
   *
   * @param reader   the new input stream 
   */
  final public void yyreset(java.io.Reader reader) throws java.io.IOException {
    yyclose();
    yy_reader = reader;
    yy_atBOL  = true;
    yy_atEOF  = false;
    yy_endRead = yy_startRead = 0;
    yy_currentPos = yy_markedPos = yy_pushbackPos = 0;
    yyline = yychar = yycolumn = 0;
    yy_lexical_state = YYINITIAL;
  }


  /**
   * Returns the current lexical state.
   */
  final public int yystate() {
    return yy_lexical_state;
  }


  /**
   * Enters a new lexical state
   *
   * @param newState the new lexical state
   */
  final public void yybegin(int newState) {
    yy_lexical_state = newState;
  }


  /**
   * Returns the text matched by the current regular expression.
   */
  final public String yytext() {
    return new String( yy_buffer, yy_startRead, yy_markedPos-yy_startRead );
  }


  /**
   * Returns the character at position <tt>pos</tt> from the 
   * matched text. 
   * 
   * It is equivalent to yytext().charAt(pos), but faster
   *
   * @param pos the position of the character to fetch. 
   *            A value from 0 to yylength()-1.
   *
   * @return the character at position pos
   */
  final public char yycharat(int pos) {
    return yy_buffer[yy_startRead+pos];
  }


  /**
   * Returns the length of the matched text region.
   */
  final public int yylength() {
    return yy_markedPos-yy_startRead;
  }


  /**
   * Reports an error that occured while scanning.
   *
   * In a wellformed scanner (no or only correct usage of 
   * yypushback(int) and a match-all fallback rule) this method 
   * will only be called with things that "Can't Possibly Happen".
   * If this method is called, something is seriously wrong
   * (e.g. a JFlex bug producing a faulty scanner etc.).
   *
   * Usual syntax/scanner level error handling should be done
   * in error fallback rules.
   *
   * @param   errorCode  the code of the errormessage to display
   */
  private void yy_ScanError(int errorCode) {
    String message;
    try {
      message = YY_ERROR_MSG[errorCode];
    }
    catch (ArrayIndexOutOfBoundsException e) {
      message = YY_ERROR_MSG[YY_UNKNOWN_ERROR];
    }

    throw new Error(message);
  } 


  /**
   * Pushes the specified amount of characters back into the input stream.
   *
   * They will be read again by then next call of the scanning method
   *
   * @param number  the number of characters to be read again.
   *                This number must not be greater than yylength()!
   */
  private void yypushback(int number)  {
    if ( number > yylength() )
      yy_ScanError(YY_PUSHBACK_2BIG);

    yy_markedPos -= number;
  }


  /**
   * Contains user EOF-code, which will be executed exactly once,
   * when the end of file is reached
   */
  private void yy_do_eof() throws java.io.IOException {
    if (!yy_eof_done) {
      yy_eof_done = true;
      yyclose();
    }
  }


  /**
   * Resumes scanning until the next regular expression is matched,
   * the end of input is encountered or an I/O-Error occurs.
   *
   * @return      the next token
   * @exception   IOException  if any I/O-Error occurs
   */
  public java_cup.runtime.Symbol next_token() throws java.io.IOException {
    int yy_input;
    int yy_action;

    // cached fields:
    int yy_currentPos_l;
    int yy_startRead_l;
    int yy_markedPos_l;
    int yy_endRead_l = yy_endRead;
    char [] yy_buffer_l = yy_buffer;
    char [] yycmap_l = yycmap;

    int [] yytrans_l = yytrans;
    int [] yy_rowMap_l = yy_rowMap;
    byte [] yy_attr_l = YY_ATTRIBUTE;

    while (true) {
      yy_markedPos_l = yy_markedPos;

      boolean yy_r = false;
      for (yy_currentPos_l = yy_startRead; yy_currentPos_l < yy_markedPos_l;
                                                             yy_currentPos_l++) {
        switch (yy_buffer_l[yy_currentPos_l]) {
        case '\u000B':
        case '\u000C':
        case '\u0085':
        case '\u2028':
        case '\u2029':
          yyline++;
          yycolumn = 0;
          yy_r = false;
          break;
        case '\r':
          yyline++;
          yycolumn = 0;
          yy_r = true;
          break;
        case '\n':
          if (yy_r)
            yy_r = false;
          else {
            yyline++;
            yycolumn = 0;
          }
          break;
        default:
          yy_r = false;
          yycolumn++;
        }
      }

      if (yy_r) {
        // peek one character ahead if it is \n (if we have counted one line too much)
        boolean yy_peek;
        if (yy_markedPos_l < yy_endRead_l)
          yy_peek = yy_buffer_l[yy_markedPos_l] == '\n';
        else if (yy_atEOF)
          yy_peek = false;
        else {
          boolean eof = yy_refill();
          yy_markedPos_l = yy_markedPos;
          yy_buffer_l = yy_buffer;
          if (eof) 
            yy_peek = false;
          else 
            yy_peek = yy_buffer_l[yy_markedPos_l] == '\n';
        }
        if (yy_peek) yyline--;
      }
      yy_action = -1;

      yy_startRead_l = yy_currentPos_l = yy_currentPos = 
                       yy_startRead = yy_markedPos_l;

      yy_state = yy_lexical_state;


      yy_forAction: {
        while (true) {

          if (yy_currentPos_l < yy_endRead_l)
            yy_input = yy_buffer_l[yy_currentPos_l++];
          else if (yy_atEOF) {
            yy_input = YYEOF;
            break yy_forAction;
          }
          else {
            // store back cached positions
            yy_currentPos  = yy_currentPos_l;
            yy_markedPos   = yy_markedPos_l;
            boolean eof = yy_refill();
            // get translated positions and possibly new buffer
            yy_currentPos_l  = yy_currentPos;
            yy_markedPos_l   = yy_markedPos;
            yy_buffer_l      = yy_buffer;
            yy_endRead_l     = yy_endRead;
            if (eof) {
              yy_input = YYEOF;
              break yy_forAction;
            }
            else {
              yy_input = yy_buffer_l[yy_currentPos_l++];
            }
          }
          int yy_next = yytrans_l[ yy_rowMap_l[yy_state] + yycmap_l[yy_input] ];
          if (yy_next == -1) break yy_forAction;
          yy_state = yy_next;

          int yy_attributes = yy_attr_l[yy_state];
          if ( (yy_attributes & 1) == 1 ) {
            yy_action = yy_state; 
            yy_markedPos_l = yy_currentPos_l; 
            if ( (yy_attributes & 8) == 8 ) break yy_forAction;
          }

        }
      }

      // store back cached position
      yy_markedPos = yy_markedPos_l;

      switch (yy_action) {

        case 71: 
          {  return symbol(PREPLUSPLUS);  }
        case 127: break;
        case 39: 
          {  string.append( yytext() );  }
        case 128: break;
        case 85: 
        case 86: 
        case 87: 
        case 88: 
        case 89: 
        case 90: 
        case 91: 
        case 92: 
          {  throw new RuntimeException("Illegal escape sequence \""+yytext()+"\"");  }
        case 129: break;
        case 75: 
          {  throw new RuntimeException("Illegal escape sequence \""+yytext()+"\"");  }
        case 130: break;
        case 3: 
        case 11: 
        case 34: 
        case 35: 
        case 43: 
        case 44: 
        case 47: 
          {  throw new RuntimeException("Illegal character \""+yytext()+
                                                              "\" at line "+yyline+", column "+yycolumn);  }
        case 131: break;
        case 12: 
          {  yybegin(STRING); string.setLength(0);  }
        case 132: break;
        case 40: 
        case 41: 
          {  throw new RuntimeException("Unterminated string at end of line");  }
        case 133: break;
        case 125: 
          {  return symbol(printf);  }
        case 134: break;
        case 72: 
          {  return symbol(MINUSEQ);  }
        case 135: break;
        case 70: 
          {  return symbol(PLUSEQ);  }
        case 136: break;
        case 26: 
          {  return symbol(RBRACE);  }
        case 137: break;
        case 25: 
          {  return symbol(LBRACE);  }
        case 138: break;
        case 24: 
          {  return symbol(RPAREN);  }
        case 139: break;
        case 23: 
          {  return symbol(LPAREN);  }
        case 140: break;
        case 4: 
        case 5: 
          {  /* ignore */  }
        case 141: break;
        case 50: 
          {  return symbol(MULTEQ);  }
        case 142: break;
        case 83: 
          {  string.append( '\b' );  }
        case 143: break;
        case 82: 
          {  string.append( '\f' );  }
        case 144: break;
        case 81: 
          {  string.append( '\t' );  }
        case 145: break;
        case 80: 
          {  string.append( '\r' );  }
        case 146: break;
        case 79: 
          {  string.append( '\n' );  }
        case 147: break;
        case 78: 
          {  string.append( '\\' );  }
        case 148: break;
        case 77: 
          {  string.append( '\'' );  }
        case 149: break;
        case 76: 
          {  string.append( '\"' );  }
        case 150: break;
        case 98: 
          {  return symbol(FOR);  }
        case 151: break;
        case 95: 
          {  return symbol(INT);  }
        case 152: break;
        case 69: 
          {  return symbol(OR);  }
        case 153: break;
        case 31: 
          {  return symbol(LT);  }
        case 154: break;
        case 30: 
          {  return symbol(GT);  }
        case 155: break;
        case 29: 
          {  return symbol(EQ);  }
        case 156: break;
        case 6: 
          {  return symbol(DIV);  }
        case 157: break;
        case 32: 
          {  return symbol(NOT);  }
        case 158: break;
        case 38: 
          {  return symbol(MOD);  }
        case 159: break;
        case 55: 
          {  return symbol(IF);  }
        case 160: break;
        case 68: 
          {  return symbol(AND);  }
        case 161: break;
        case 27: 
          {  return symbol(SEMICOLON);  }
        case 162: break;
        case 45: 
        case 46: 
          {  throw new RuntimeException("Unterminated character literal at end of line");  }
        case 163: break;
        case 124: 
          {  return symbol(WHILE);  }
        case 164: break;
        case 123: 
          {  return symbol(scanf);  }
        case 165: break;
        case 122: 
          {  return symbol(FLOAT);  }
        case 166: break;
        case 119: 
          {  return symbol(GOTO);  }
        case 167: break;
        case 118: 
          {  return symbol(ELSE);  }
        case 168: break;
        case 117: 
          {  return symbol(CHAR);  }
        case 169: break;
        case 113: 
          {  return symbol(main);  }
        case 170: break;
        case 74: 
          {  return symbol(MODEQ);  }
        case 171: break;
        case 28: 
          {  return symbol(COMMA);  }
        case 172: break;
        case 7: 
          {  return symbol(MULT);  }
        case 173: break;
        case 33: 
          {  return symbol(COLON);  }
        case 174: break;
        case 36: 
          {  return symbol(PLUS);  }
        case 175: break;
        case 37: 
          {  return symbol(MINUS);  }
        case 176: break;
        case 49: 
          {  return symbol(DIVEQ);  }
        case 177: break;
        case 64: 
          {  return symbol(EQEQ);  }
        case 178: break;
        case 65: 
          {  return symbol(GTEQ);  }
        case 179: break;
        case 66: 
          {  return symbol(LTEQ);  }
        case 180: break;
        case 67: 
          {  return symbol(NOTEQ);  }
        case 181: break;
        case 8: 
        case 14: 
        case 15: 
        case 16: 
        case 17: 
        case 18: 
        case 19: 
        case 20: 
        case 21: 
        case 22: 
        case 53: 
        case 54: 
        case 56: 
        case 57: 
        case 58: 
        case 59: 
        case 60: 
        case 61: 
        case 62: 
        case 63: 
        case 94: 
        case 96: 
        case 97: 
        case 99: 
        case 100: 
        case 101: 
        case 102: 
        case 103: 
        case 114: 
        case 115: 
        case 116: 
        case 120: 
        case 121: 
          {  return symbol(IDENTIFIER, yytext());  }
        case 182: break;
        case 42: 
          {  yybegin(YYINITIAL); return symbol(STRING_LITERAL, string.toString());  }
        case 183: break;
        case 106: 
          {  yybegin(YYINITIAL); return symbol(CHARACTER_LITERAL, new Character('\\'));  }
        case 184: break;
        case 73: 
          {  return symbol(PREMINUSMINUS);  }
        case 185: break;
        case 84: 
          {  yybegin(YYINITIAL); return symbol(CHARACTER_LITERAL, new Character(yytext().charAt(0)));  }
        case 186: break;
        case 51: 
        case 52: 
          {  return symbol(FLOATING_POINT_LITERAL, new Float(yytext().substring(0,yylength()-1)));  }
        case 187: break;
        case 111: 
          {  yybegin(YYINITIAL); return symbol(CHARACTER_LITERAL, new Character('\b')); }
        case 188: break;
        case 110: 
          {  yybegin(YYINITIAL); return symbol(CHARACTER_LITERAL, new Character('\f')); }
        case 189: break;
        case 109: 
          {  yybegin(YYINITIAL); return symbol(CHARACTER_LITERAL, new Character('\t')); }
        case 190: break;
        case 108: 
          {  yybegin(YYINITIAL); return symbol(CHARACTER_LITERAL, new Character('\r')); }
        case 191: break;
        case 107: 
          {  yybegin(YYINITIAL); return symbol(CHARACTER_LITERAL, new Character('\n')); }
        case 192: break;
        case 105: 
          {  yybegin(YYINITIAL); return symbol(CHARACTER_LITERAL, new Character('\'')); }
        case 193: break;
        case 104: 
          {  yybegin(YYINITIAL); return symbol(CHARACTER_LITERAL, new Character('\"')); }
        case 194: break;
        case 9: 
        case 10: 
          {  return symbol(INTEGER_LITERAL, new Integer(yytext()));  }
        case 195: break;
        case 13: 
          {  yybegin(CHARLITERAL);  }
        case 196: break;
        default: 
          if (yy_input == YYEOF && yy_startRead == yy_currentPos) {
            yy_atEOF = true;
            yy_do_eof();
              {  return symbol(EOF);  }
          } 
          else {
            yy_ScanError(YY_NO_MATCH);
          }
      }
    }
  }


}
